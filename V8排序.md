##1. 概述：
- v8 是 Chrome 的javascript 引擎，其中关于数组的排序完全采用了js实现。
- 当数组长度小于等于 10 时，采用插入排序，大于 10 的时候，采用快速排序。(当然了，这种说法并不严谨)。
- 时间复杂度：
  是算法所需要的计算工作量，它考虑当输入值大小趋近无穷大时的情况。
- 空间复杂度：
  
- 稳定性：
  相同的元素在排序后是否还保持相对的位置。对于不稳定的排序算法，只要举出一个实例，即可以说明它的不稳定性，对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。
## 2. 插入排序：
- 优势， 在快要排序好的状态，或者，问题规模比较小的时候，插入排序效率更高。
```
function insertionSort(arr) {
  for (let i = 1, length = arr.length; i < length; i++) {
    var temp = arr[i];
    let j = i - 1;
    while(j >= 0) {
      if (arr[j] > temp) {
        arr[j+1] = arr[j]
      } else {
        break;
      }
      j--;
    }
    arr[j+1] = temp;
  }
  return arr
}
var arr = [6, 5, 4, 3, 2, 1];
console.log(insertionSort(arr));
```
## 3. 快速排序
- 原理：
  - 选择一个元素作为"基准"
  - 小于"基准"的元素，都移到"基准"的左边；大于"基准"的元素，都移到"基准"的右边。
  - 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
```
var quickSort = function(arr) {
  if (arr.length <= 1) return arr;
  let pivotIndex = Math.floor(arr.length / 2);
  let pivot = arr.splice(pivotIndex, 1)[0];
  let left = [], right = [];
  for(let i = 0, length = arr.length; i < length; i++) {
    if (arr[i] < pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }
  return quickSort(left).concat([pivot], quickSort(right));
};
console.log(quickSort(arr));
```
