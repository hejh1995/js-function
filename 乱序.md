## 1. Math.random --- 不能真正实现乱序：
```
var values = [1,2,3,4,5];
values.sort(() => Math.ramdom() - 0.5);
// 因为在v8 中， 当目标数组长度小于10， 使用插入排序， 反之使用 快排 和 插入 排序的 混合排序。
// 当插入排序中， 待排序元素跟有序元素进行比较时， 一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就乱序的不彻底了。
```
- 下面分析一下 [1, 2, 3] 这个数组的乱序的过程：
第一次：第一次比较(1, 2), 有 50% 的可能性 变成(2,1) ,有 50% 的可能性 仍然是(1,2)。
第二次：
  - 如果还是（1，2，3），比较（2，3），有 50% 的可能性 变成(3，2) ，有 50% 的可能性 仍然是(2，3)。因为变为（3，2）变化了，所以还需要再变一次， 所以，这次比较（1，3）， 有 50% 的可能性 变成(3，1) ,有 50% 的可能性 仍然是(1，3)。
故这次得到的结论， （1，3，2） 12.5%， （3，1，2） 12.5%， （1，2，3） 25%；
  - 如果是（2，1，3），比较（1，3），有 50% 的可能性 变成(3，1) ，有 50% 的可能性 仍然是(1，3)。因为变为（3，1）变化了，所以还需要再变一次， 所以，这次比较（2，3）， 有 50% 的可能性 变成(3，2) ,有 50% 的可能性 仍然是(2，3)。
故这次得到的结论， （2，3，1） 12.5%， （3，2，1） 12.5%， （2，1，3） 25%；
最终得到的概率分布为：（1，3，2） 12.5%，（3，1，2） 12.5%，（1，2，3） 25%；（2，3，1） 12.5%， （3，2，1） 12.5%， （2，1，3） 25%；
## 2. 真正的乱序 ---- 洗牌算法
```
functoin shuffle (arr) {
  for (let i = arr.length ; i > 0; i--) {
    let j = Math.floor(Math.random() * i);
    [arr[i-1], arr[j]] = [arr[j], arr[i-1]];
  }
  return arr;
}
```
